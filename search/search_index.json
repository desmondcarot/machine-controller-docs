{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"abc","text":"<p>Machine Controller is a backend system designed to control and manage multiple machines asynchronously using image recognition. It leverages OpenCV's template matching to execute task flows, and provides a web interface for real-time interaction and control.</p>"},{"location":"#tech-stack","title":"Tech Stack","text":"<ul> <li>Backend: FastAPI (REST API + frontend server)</li> <li>Image Recognition: OpenCV (template matching)</li> <li>Frontend: HTML/CSS/JS served via FastAPI</li> <li>Concurrency: Python <code>asyncio</code></li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Add or remove machines</li> <li>List all registered machines</li> <li>Start/stop asynchronous task loops</li> <li>Perform manual control operations</li> <li>Visual feedback via camera and image processing</li> </ul>"},{"location":"#control-interface","title":"Control Interface","text":"<p>Available via Web UI or REST API:</p> Function Description Add Machine Register a new machine with its configuration List Machine View all machines in the system Start Task Loop Begin automated task execution Stop Task Loop Stop the current task execution loop Manual Control Direct control over machine movement/actions"},{"location":"#directory-overview","title":"Directory Overview","text":"<pre><code>project-root/\n\u251c\u2500\u2500 logs/                          # Logging output folder (runtime)\n\u251c\u2500\u2500 MachineController/             # Core logic\n\u2502   \u251c\u2500\u2500 __init__.py                # Module initialization\n\u2502   \u251c\u2500\u2500 camera_repo/               # Camera device connection &amp; logic\n\u2502   \u251c\u2500\u2500 classes.py                 # Supplementary classes\n\u2502   \u251c\u2500\u2500 device_action/             # Device-specific action handlers\n\u2502   \u251c\u2500\u2500 globals.py                 # Global variables and constants\n\u2502   \u251c\u2500\u2500 logger_config.py           # Logging setup and formatting\n\u2502   \u251c\u2500\u2500 machine_controller.py      # Controls multiple machines, exposes methods to FastAPI\n\u2502   \u251c\u2500\u2500 machine.py                 # Task loop logic for each machine\n\u2502   \u251c\u2500\u2500 serial_connection.py       # Serial communication and camera handling\n\u2502   \u2514\u2500\u2500 utils.py                   # Helper functions\n\u251c\u2500\u2500 web/                           # Frontend assets (HTML/CSS/JS)\n\u251c\u2500\u2500 config.json                    # Global configuration file\n\u251c\u2500\u2500 main.py                        # FastAPI app entry point\n\u2514\u2500\u2500 requirements.txt               # Python dependenciess\n</code></pre>"},{"location":"#thanks","title":"Thanks!","text":"\ud83d\ude80 Custom HTML Section <p>You can embed HTML directly into your Markdown files in MkDocs.</p> Start Here \u2192"},{"location":"architecture/","title":"Project Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":""},{"location":"architecture/#1-project-architecture","title":"1. Project Architecture","text":"<p>The system is built around the <code>Machine</code> class.</p> <ul> <li> <p>Each <code>Machine</code> holds:</p> <ul> <li>Multiple references to <code>Device</code> objects</li> <li>A single <code>SerialConnection</code></li> <li>A <code>CameraRepo</code> (indirectly, via <code>SerialConnection</code>)</li> </ul> </li> <li> <p>The <code>MachineController</code> serves as the orchestrator:</p> <ul> <li>It maintains a list of <code>Machine</code> instances</li> <li>It provides high-level control and coordination between machines</li> <li>It exposes control methods to FastAPI (in <code>main.py</code>)</li> </ul> </li> <li> <p>FastAPI exposes internal APIs to the frontend web UI for real-time control.</p> </li> </ul>"},{"location":"architecture/#core-component-overview","title":"Core Component Overview","text":""},{"location":"architecture/#class-machine","title":"Class <code>Machine</code>","text":"<p>The <code>Machine</code> class encapsulates all functionality related to a single physical machine. It manages:</p> <ul> <li>A list of <code>Devices</code> (e.g., actuators or task points)</li> <li>A <code>SerialConnection</code> (for communication)</li> <li>A <code>CameraRepo</code> (for vision-based feedback)</li> </ul> <p>Its functionality include: - Retrieving tasks from the server - Executing tasks asynchronously - Updating task completion status</p>"},{"location":"architecture/#class-serialconnection","title":"Class <code>SerialConnection</code>","text":"<p>The <code>SerialConnection</code> class manages communication between a serial device (e.g. The Machine) and a camera interface <code>CameraRepo</code>. It allows asynchronous sending of custom command sequences over a serial port and can trigger image captures from an attached camera. This class ensures thread-safe interactions using an asyncio.Lock, handles connection recovery in case of failure, and provides logging for all major actions.</p>"},{"location":"architecture/#class-commands","title":"Class <code>Commands</code>","text":"<p>The Commands class represents a single instruction to be sent to a machine via serial communication. It is used to encode positional movements and special actions, such as triggering a camera capture.</p> <p>Each instance contains:</p> <ul> <li>positionX, positionY, positionZ: Axis movement values.</li> <li>sleep: Delay (in seconds) to wait after executing the command.</li> <li>capture: If True, the command triggers an image capture instead of movement.</li> </ul> <p>The class automatically encodes the instruction into a byte string (command_byte) for transmission over a serial connection.</p>"},{"location":"architecture/#class-camerarepo","title":"Class <code>CameraRepo</code>","text":"<p>The <code>CameraRepo</code> class handles continuous video capture from a connected camera device. It abstracts camera initialization, live frame retrieval, and auto-recovery from capture failures. A background thread is used to continuously update the latest frame in real-time.</p> <p>Key Features:</p> <ul> <li>Auto-backend fallback: Tries cv2.CAP_DSHOW first; falls back to cv2.CAP_MSMF if needed.</li> <li>Threaded frame update: Uses a daemon thread to keep the latest frame updated in memory.</li> <li>Thread-safe access: Uses a threading.Lock to prevent race conditions while accessing the frame. Frame serving: Provides the most recent camera frame to other components (e.g., for processing &amp;&amp; display).</li> </ul>"},{"location":"architecture/#class-device","title":"Class <code>Device</code>","text":"<p>The <code>Device</code> class represents the individual device on the machine. It operates relative to an initial reference position of each device and stores a queue of <code>commands</code> (movement, click, capture, etc.) that can be executed asynchronously via a shared <code>SerialConnection</code>.</p>"},{"location":"architecture/#class-machinecontroller","title":"Class <code>MachineController</code>","text":"<p>The MachineController class manages a list of Machine instances and acts as the main control interface for the system. It provides methods to add, remove, configure, and control machines, as well as expose machine data and actions through FastAPI, enabling web-based control.</p> <p>It serves as the entry point for interacting with physical machines and their devices in a scalable, centralized way.</p> <p>Key Responsibilities:</p> <ul> <li>Maintain a registry of all active machines.</li> <li>Handle config file I/O (config.json) to persist and restore machine setups.</li> <li>Expose machine status and actions to the frontend via FastAPI.</li> <li>Facilitate machine operations such as:<ul> <li>Start/stop/test machine</li> <li>Manual Machine movement</li> <li>Calibrating machine origin</li> <li>Generating camera preview frames</li> </ul> </li> </ul>"},{"location":"architecture/#additional-component-overview","title":"Additional Component Overview","text":""},{"location":"architecture/#globalspy","title":"globals.py","text":"<p>Stores global variables and configuration flags that persist across modules. Commonly used for debug toggles (<code>DEBUG</code>, <code>DEBUG_IMAGE_SCAN</code>) and other shared runtime states.</p>"},{"location":"architecture/#logger_configpy","title":"logger_config.py","text":"<p>Defines the application's logging configuration. Exposes a reusable <code>InstanceLogger</code> utility to create named loggers with standardized formatting and levels across modules.</p>"},{"location":"architecture/#utilspy","title":"utils.py","text":"<p>Contains generic utility/helper functions used throughout the application. These functions support reusable logic and reduce code duplication in the main modules.</p>"},{"location":"example/","title":"Examples","text":"<p>Below are the examples to set up machines / and perform some action to help you get a feel of what the program is used.</p> <ol> <li>Start with initializing MachineController</li> </ol> main.py<pre><code>from MachineController import MachineController\n\ncontroller = MachineController()\n</code></pre> <ol> <li>create instance of connection for the new machine</li> </ol> <p>Create new CameraRepo instance</p> <p>CameraRepo<pre><code>from MachineController import CameraRepo\n\ncam_index = 0\ncam_repo = Camera(cam_index)\n</code></pre> Create new Serial Connection instance</p> SerialConnection<pre><code>from MachineController import SerialConnection\n\nserial = Serial('COM4',93400)\nconnection = SerialConnection(serial, cam_repo)\n</code></pre> <p>Use MachineController.list_available_ports() and list_available_cameras() to find availalbe ports.</p> <ol> <li>Now intialize a new Machine within for the MachineController:</li> </ol> Machine<pre><code>from MachineController import Machine\n\nid=1 #the machine identifier\ncontroller.machines.append(Machine(connection,id,cam_index))\n</code></pre> <p>or you can skip step 2 and just init with</p> Machine<pre><code>from MachineController import Machine\n\nid=1 #the machine identifier\ncontroller.machines.append()\n</code></pre> <ol> <li>We can now call MachineController to perform task on the machine like:</li> </ol> MachineController<pre><code>await controller.test_machine(id)\nawait controller.click_machine(id)\n</code></pre>"},{"location":"settingup/","title":"Setting up the project","text":""},{"location":"settingup/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure the following tools are installed:</p> <ul> <li>Python 3.10+ \u2014 Main development language  </li> <li>Visual Studio Code (VSCode) \u2014 Recommended IDE  </li> <li>Virtual Environment \u2014 Optional but recommended for dependency isolation</li> </ul>"},{"location":"settingup/#installation-running-the-project","title":"Installation &amp; Running the Project","text":""},{"location":"settingup/#standard-setup","title":"Standard Setup","text":"<ol> <li> <p>Navigate to the root of the project:     bash<pre><code>cd path/to/project\n</code></pre></p> </li> <li> <p>Install dependencies using <code>pip</code>:     bash<pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Run the application:     bash<pre><code>python main.py\n</code></pre></p> </li> </ol>"},{"location":"settingup/#optional-using-uv-and-virtual-environment","title":"Optional: Using <code>uv</code> and Virtual Environment","text":"<p>This is a cleaner way to manage dependencies using <code>uv</code>, a fast Python package manager.</p> <ol> <li> <p>Navigate to the project folder:     bash<pre><code>cd path/to/project\n</code></pre></p> </li> <li> <p>Install <code>uv</code>:     bash<pre><code>pip install uv\n</code></pre></p> </li> <li> <p>Create a virtual environment:     bash<pre><code>uv venv\n</code></pre></p> </li> <li> <p>Activate the virtual environment:</p> <ul> <li> <p>Windows:   bash<pre><code>.venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>macOS/Linux:   bash<pre><code>source .venv/bin/activate\n</code></pre></p> </li> </ul> <p>\u26a0\ufe0f If the <code>uv</code> or <code>pip</code> command is not found, make sure the Python <code>Scripts/</code> folder is added to your system PATH environment variable.</p> </li> <li> <p>Install dependencies:     bash<pre><code>uv pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Run the app:     bash<pre><code>python main.py\n</code></pre></p> </li> <li> <p>You should see FastAPI running on <code>http://localhost:8000</code></p> </li> </ol>"},{"location":"modules/camerarepo/","title":"Class CameraRepo","text":""},{"location":"modules/device/","title":"Device","text":""},{"location":"modules/machine/","title":"Machine","text":"<p>The Machine class encapsulates all functionality related to a single physical machine. It manages:</p> <p>A list of Devices (e.g., actuators or task points) A SerialConnection (for communication) A CameraRepo (for vision-based feedback) Its functionality include: - Retrieving tasks from the server - Executing tasks asynchronously - Updating task completion status</p>"},{"location":"modules/machine/#methods","title":"Methods","text":""},{"location":"modules/machine/#usage-examples","title":"Usage Examples","text":"<p>When calling a method like <code>get_rhb_task()</code>, the server returns a structure like this:</p> <p><pre><code>{\n  \"ResponseCode\": 200,\n  \"ResponseData\": [\n    {\n      \"TaskId\": 1,\n      \"BankUsername\": \"aaaaaaa\",\n      \"Slot\": \"1\"\n    },\n    {\n      \"TaskId\": 3,\n      \"BankUsername\": \"ccccccc\",\n      \"Slot\": \"2\"\n    }\n  ],\n  \"ResponseMsg\": \"Success.\"\n}\n</code></pre> <code>TaskId</code>: The unique identifier for the task</p> <p><code>Slot</code>: Indicates the specific device to use within the machine</p> <p><code>BankUsername</code>: Metadata used during task execution</p> <p>For each task in ResponseData, the machine will call approve_rhb() asynchronously. This enables multiple tasks to run concurrently for task in different devices.</p> <p>For example: <pre><code>Slot 1 \u2192 Device[0]\n\nSlot 2 \u2192 Device[1]\n</code></pre></p>"},{"location":"modules/machine/#internal-execution-loop","title":"Internal execution loop","text":"<p>When automation is triggered, the <code>run_rhb_loop()</code> method runs indefinitely until explicitly stopped.</p> <pre><code>1. Retrieve task\n2. Begin task loop (via approve_rhb):\n   a. Move camera to the target device position\n   b. Capture image from the camera\n   c. Match image against predefined templates\n   d. Based on best match, determine next step\n   e. Repeat steps a\u2013c for sub-tasks\n   f. Stop loop if:\n      - \u2705 Task completed successfully\n      - \u274c Failure conditions met:\n         \u2022 Exceeded 7 cycles\n         \u2022 Failed 2 consecutive template matches\n3. Update task status\n4. Repeat from Step 1\n</code></pre> <p>Multiple machines can run this loop in parallel, independently.</p>"},{"location":"modules/machine/#io-safeguards-resource-management","title":"IO Safeguards &amp; Resource Management","text":"<p>Each machine is a limited and shared hardware resource. To ensure maximum concurrency without causing race conditions or unsafe operations, the <code>Machine</code> class uses <code>asyncio.Lock()</code> and <code>asyncio.Event()</code> for cooperative multitasking.</p> <p>These synchronization primitives are initialized in the constructor:</p> <pre><code>class Machine:\n    def __init__(self, connection, id: int, cam_index: int):\n        self.lock: asyncio.Lock = asyncio.Lock()\n        self.stop_event: asyncio.Event = asyncio.Event()\n        self.id: int = id\n        self.cam_index: int = cam_index\n        self.connection: SerialConnection = connection\n        self.devices: List[DeviceAction] = [\n            DeviceAction(connection, 18, 28, 1),\n            DeviceAction(connection, 105, 28, 2),\n            DeviceAction(connection, 192, 28, 3),\n            DeviceAction(connection, 279, 28, 4)\n        ]\n        self.is_running: bool = False\n        self.is_enabled: bool = True\n</code></pre>"},{"location":"modules/machine/#why-use-lock","title":"Why Use Lock?","text":"<p>Any function that mutates the state of the machine \u2014 like stopping a task \u2014 must acquire the lock first. This ensures that no two asynchronous routines modify or interfere with the machine at the same time.</p> <p>Here\u2019s an example from the <code>trigger_stop()</code> method:</p> <pre><code>async def trigger_stop(self):\n    async with self.lock:\n        self.stop_event.set()\n        self.is_running = False\n</code></pre>"},{"location":"modules/machine/#benefits-of-using-asynciolock","title":"Benefits of Using <code>asyncio.Lock()</code>","text":"<ol> <li> <p>Ensures safe command execution Prevents mid-task state changes, which could corrupt the machine\u2019s state or cause unexpected hardware behavior.</p> </li> <li> <p>Prevents overlapping access Since multiple tasks can be scheduled concurrently, the lock ensures one set of task finishes interacting with the machine before another set of tasks begins.</p> </li> </ol>"},{"location":"modules/serialconnection/","title":"SerialConnection","text":"<p>The <code>SerialConnection</code> class manages communication between a serial device (e.g. The Machine) and a camera interface <code>CameraRepo</code>. It allows asynchronous sending of custom command sequences over a serial port and can trigger image captures from an attached camera. This class ensures thread-safe interactions using an asyncio.Lock, handles connection recovery in case of failure, and provides logging for all major actions.</p>"},{"location":"modules/serialconnection/#commands","title":"Commands","text":"<p>The Commands class represents a single instruction to be sent to a machine via serial communication. It is used to encode positional movements and special actions, such as triggering a camera capture.</p> <p>Each instance contains:</p> <ul> <li>positionX, positionY, positionZ: Axis movement values.</li> <li>sleep: Delay (in seconds) to wait after executing the command.</li> <li>capture: If True, the command triggers an image capture instead of movement.</li> </ul> <p>The class automatically encodes the instruction into a byte string (command_byte) for transmission over a serial connection.</p>"}]}