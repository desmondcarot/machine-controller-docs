{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome To Machine Controller","text":"<p>Machine Controller is a backend system designed to control and manage multiple machines asynchronously using image recognition. It leverages OpenCV's template matching to execute task flows, and provides a web interface for real-time interaction and control.</p>"},{"location":"#tech-stack","title":"Tech Stack","text":"<ul> <li>Backend: FastAPI (REST API + frontend server)</li> <li>Image Recognition: OpenCV (template matching)</li> <li>Frontend: HTML/CSS/JS served via FastAPI</li> <li>Concurrency: Python <code>asyncio</code></li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Add or remove machines</li> <li>List all registered machines</li> <li>Start/stop asynchronous task loops</li> <li>Perform manual control operations</li> <li>Visual feedback via camera and image processing</li> </ul>"},{"location":"#control-interface","title":"Control Interface","text":"<p>Available via Web UI or REST API:</p> Function Description Add Machine Register a new machine with its configuration List Machine View all machines in the system Start Task Loop Begin automated task execution Stop Task Loop Stop the current task execution loop Manual Control Direct control over machine movement/actions"},{"location":"#directory-overview","title":"Directory Overview","text":"<pre><code>project-root/\n\u251c\u2500\u2500 logs/                          # Logging output folder (runtime)\n\u251c\u2500\u2500 MachineController/             # Core logic\n\u2502   \u251c\u2500\u2500 __init__.py                # Module initialization\n\u2502   \u251c\u2500\u2500 camera_repo/               # Camera device connection &amp; logic\n\u2502   \u251c\u2500\u2500 classes.py                 # Supplementary classes\n\u2502   \u251c\u2500\u2500 device_action/             # Device-specific action handlers\n\u2502   \u251c\u2500\u2500 globals.py                 # Global variables and constants\n\u2502   \u251c\u2500\u2500 logger_config.py           # Logging setup and formatting\n\u2502   \u251c\u2500\u2500 machine_controller.py      # Controls multiple machines, exposes methods to FastAPI\n\u2502   \u251c\u2500\u2500 machine.py                 # Task loop logic for each machine\n\u2502   \u251c\u2500\u2500 serial_connection.py       # Serial communication and camera handling\n\u2502   \u2514\u2500\u2500 utils.py                   # Helper functions\n\u251c\u2500\u2500 web/                           # Frontend assets (HTML/CSS/JS)\n\u251c\u2500\u2500 config.json                    # Global configuration file\n\u251c\u2500\u2500 main.py                        # FastAPI app entry point\n\u2514\u2500\u2500 requirements.txt               # Python dependencies\n</code></pre>"},{"location":"#setting-up-the-project","title":"Setting up the project","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure the following tools are installed:</p> <ul> <li>Python 3.10+ \u2014 Main development language  </li> <li>Visual Studio Code (VSCode) \u2014 Recommended IDE  </li> <li>Virtual Environment \u2014 Optional but recommended for dependency isolation</li> </ul>"},{"location":"#installation-running-the-project","title":"\u2699\ufe0f Installation &amp; Running the Project","text":""},{"location":"#standard-setup","title":"Standard Setup","text":"<ol> <li> <p>Navigate to the root of the project:     bash<pre><code>cd path/to/project\n</code></pre></p> </li> <li> <p>Install dependencies using <code>pip</code>:     bash<pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Run the application:     bash<pre><code>python main.py\n</code></pre></p> </li> </ol>"},{"location":"#optional-using-uv-and-virtual-environment","title":"Optional: Using <code>uv</code> and Virtual Environment","text":"<p>This is a cleaner way to manage dependencies using <code>uv</code>, a fast Python package manager.</p> <ol> <li> <p>Navigate to the project f older:     bash<pre><code>cd path/to/project\n</code></pre></p> </li> <li> <p>Install <code>uv</code>:     bash<pre><code>pip install uv\n</code></pre></p> </li> <li> <p>Create a virtual environment:     bash<pre><code>uv venv\n</code></pre></p> </li> <li> <p>Activate the virtual environment:</p> <ul> <li> <p>Windows:   bash<pre><code>.venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>macOS/Linux:   bash<pre><code>source .venv/bin/activate\n</code></pre></p> </li> </ul> <p>\u26a0\ufe0f If the <code>uv</code> or <code>pip</code> command is not found, make sure the Python <code>Scripts/</code> folder is added to your system PATH environment variable.</p> </li> <li> <p>Install dependencies:     bash<pre><code>uv pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Run the app:     bash<pre><code>python main.py\n</code></pre></p> </li> <li> <p>You should see FastAPI running on <code>http://localhost:8000</code></p> </li> </ol>"},{"location":"#understanding-project-structure","title":"Understanding Project Structure","text":""},{"location":"#overview","title":"\ud83e\udde0 Overview","text":""},{"location":"#1-project-architecture","title":"1. Project Architecture","text":"<p>The system is built around the <code>Machine</code> class.</p> <ul> <li>Each <code>Machine</code> holds:</li> <li>Multiple references to <code>Device</code> objects</li> <li>A single <code>SerialConnection</code></li> <li> <p>A <code>CameraRepo</code> (indirectly, via <code>SerialConnection</code>)</p> </li> <li> <p>The <code>MachineController</code> serves as the orchestrator:</p> </li> <li>It maintains a list of <code>Machine</code> instances</li> <li>It provides high-level control and coordination between machines</li> <li> <p>It exposes control methods to FastAPI (in <code>main.py</code>)</p> </li> <li> <p>FastAPI exposes internal APIs to the frontend web UI for real-time control.</p> </li> </ul>"},{"location":"#component-breakdown","title":"Component Breakdown","text":""},{"location":"#1-machine-class","title":"1. <code>Machine</code> Class","text":""},{"location":"#description","title":"Description","text":"<p>The <code>Machine</code> class encapsulates all functionality related to a single physical machine. It manages:</p> <ul> <li>A list of <code>Devices</code> (e.g., actuators or task points)</li> <li>A <code>SerialConnection</code> (for communication)</li> <li>A <code>CameraRepo</code> (for vision-based feedback)</li> </ul> <p>Its responsibilities include: - Retrieving tasks from the server - Executing tasks asynchronously - Updating task completion status</p> <p>When calling a method like <code>get_rhb_task()</code>, the server returns a structure like this:</p> <p>json<pre><code>{\n  \"ResponseCode\": 200,\n  \"ResponseData\": [\n    {\n      \"TaskId\": 1,\n      \"BankUsername\": \"aaaaaaa\",\n      \"Slot\": \"1\"\n    },\n    {\n      \"TaskId\": 3,\n      \"BankUsername\": \"ccccccc\",\n      \"Slot\": \"2\"\n    }\n  ],\n  \"ResponseMsg\": \"Success.\"\n}\n</code></pre> <code>TaskId</code>: The unique identifier for the task</p> <p><code>Slot</code>: Indicates the specific device to use within the machine</p> <p><code>BankUsername</code>: Metadata used during task execution</p> <p>For each task in ResponseData, the machine will call approve_rhb() asynchronously. This enables multiple tasks to run concurrently for task in different devices.</p> <p>For example: <pre><code>Slot 1 \u2192 Device[0]\n\nSlot 2 \u2192 Device[1]\n</code></pre></p>"},{"location":"#internal-execution-loop","title":"Internal execution loop","text":"<p>When automation is triggered, the <code>run_rhb_loop()</code> method runs indefinitely until explicitly stopped.</p> <pre><code>1. Retrieve task\n2. Begin task loop (via approve_rhb):\n   a. Move camera to the target device position\n   b. Capture image from the camera\n   c. Match image against predefined templates\n   d. Based on best match, determine next step\n   e. Repeat steps a\u2013c for sub-tasks\n   f. Stop loop if:\n      - \u2705 Task completed successfully\n      - \u274c Failure conditions met:\n         \u2022 Exceeded 7 cycles\n         \u2022 Failed 2 consecutive template matches\n3. Update task status\n4. Repeat from Step 1\n</code></pre> <p>Multiple machines can run this loop in parallel, independently.</p>"},{"location":"#io-safeguards-resource-management","title":"IO Safeguards &amp; Resource Management","text":"<p>Each machine is a limited and shared hardware resource. To ensure maximum concurrency without causing race conditions or unsafe operations, the <code>Machine</code> class uses <code>asyncio.Lock()</code> and <code>asyncio.Event()</code> for cooperative multitasking.</p> <p>These synchronization primitives are initialized in the constructor:</p> python<pre><code>class Machine:\n    def __init__(self, connection, id: int, cam_index: int):\n        self.lock: asyncio.Lock = asyncio.Lock()\n        self.stop_event: asyncio.Event = asyncio.Event()\n        self.id: int = id\n        self.cam_index: int = cam_index\n        self.connection: SerialConnection = connection\n        self.devices: List[DeviceAction] = [\n            DeviceAction(connection, 18, 28, 1),\n            DeviceAction(connection, 105, 28, 2),\n            DeviceAction(connection, 192, 28, 3),\n            DeviceAction(connection, 279, 28, 4)\n        ]\n        self.is_running: bool = False\n        self.is_enabled: bool = True\n</code></pre>"},{"location":"#why-use-lock","title":"Why Use Lock?","text":"<p>Any function that mutates the state of the machine \u2014 like stopping a task \u2014 must acquire the lock first. This ensures that no two asynchronous routines modify or interfere with the machine at the same time.</p> <p>Here\u2019s an example from the <code>trigger_stop()</code> method:</p> <pre><code>async def trigger_stop(self):\n    async with self.lock:\n        self.stop_event.set()\n        self.is_running = False\n</code></pre>"},{"location":"#benefits-of-using-asynciolock","title":"Benefits of Using <code>asyncio.Lock()</code>","text":"<ol> <li> <p>Ensures safe command execution Prevents mid-task state changes, which could corrupt the machine\u2019s state or cause unexpected hardware behavior.</p> </li> <li> <p>Prevents overlapping access Since multiple tasks can be scheduled concurrently, the lock ensures one task finishes interacting with the machine before another begins.</p> </li> </ol>"},{"location":"architecture/","title":"Project Architecture","text":""},{"location":"architecture/#overview","title":"\ud83e\udde0 Overview","text":""},{"location":"architecture/#1-project-architecture","title":"1. Project Architecture","text":"<p>The system is built around the <code>Machine</code> class.</p> <ul> <li> <p>Each <code>Machine</code> holds:</p> <ul> <li>Multiple references to <code>Device</code> objects</li> <li>A single <code>SerialConnection</code></li> <li>A <code>CameraRepo</code> (indirectly, via <code>SerialConnection</code>)</li> </ul> </li> <li> <p>The <code>MachineController</code> serves as the orchestrator:</p> <ul> <li>It maintains a list of <code>Machine</code> instances</li> <li>It provides high-level control and coordination between machines</li> <li>It exposes control methods to FastAPI (in <code>main.py</code>)</li> </ul> </li> <li> <p>FastAPI exposes internal APIs to the frontend web UI for real-time control.</p> </li> </ul>"},{"location":"architecture/#component-breakdown","title":"Component Breakdown","text":""},{"location":"architecture/#1-machine-class","title":"1. <code>Machine</code> Class","text":""},{"location":"architecture/#description","title":"Description","text":"<p>The <code>Machine</code> class encapsulates all functionality related to a single physical machine. It manages:</p> <ul> <li>A list of <code>Devices</code> (e.g., actuators or task points)</li> <li>A <code>SerialConnection</code> (for communication)</li> <li>A <code>CameraRepo</code> (for vision-based feedback)</li> </ul> <p>Its responsibilities include: - Retrieving tasks from the server - Executing tasks asynchronously - Updating task completion status</p> <p>When calling a method like <code>get_rhb_task()</code>, the server returns a structure like this:</p> <p><pre><code>{\n  \"ResponseCode\": 200,\n  \"ResponseData\": [\n    {\n      \"TaskId\": 1,\n      \"BankUsername\": \"aaaaaaa\",\n      \"Slot\": \"1\"\n    },\n    {\n      \"TaskId\": 3,\n      \"BankUsername\": \"ccccccc\",\n      \"Slot\": \"2\"\n    }\n  ],\n  \"ResponseMsg\": \"Success.\"\n}\n</code></pre> <code>TaskId</code>: The unique identifier for the task</p> <p><code>Slot</code>: Indicates the specific device to use within the machine</p> <p><code>BankUsername</code>: Metadata used during task execution</p> <p>For each task in ResponseData, the machine will call approve_rhb() asynchronously. This enables multiple tasks to run concurrently for task in different devices.</p> <p>For example: <pre><code>Slot 1 \u2192 Device[0]\n\nSlot 2 \u2192 Device[1]\n</code></pre></p>"},{"location":"architecture/#internal-execution-loop","title":"Internal execution loop","text":"<p>When automation is triggered, the <code>run_rhb_loop()</code> method runs indefinitely until explicitly stopped.</p> <pre><code>1. Retrieve task\n2. Begin task loop (via approve_rhb):\n   a. Move camera to the target device position\n   b. Capture image from the camera\n   c. Match image against predefined templates\n   d. Based on best match, determine next step\n   e. Repeat steps a\u2013c for sub-tasks\n   f. Stop loop if:\n      - \u2705 Task completed successfully\n      - \u274c Failure conditions met:\n         \u2022 Exceeded 7 cycles\n         \u2022 Failed 2 consecutive template matches\n3. Update task status\n4. Repeat from Step 1\n</code></pre> <p>Multiple machines can run this loop in parallel, independently.</p>"},{"location":"architecture/#io-safeguards-resource-management","title":"IO Safeguards &amp; Resource Management","text":"<p>Each machine is a limited and shared hardware resource. To ensure maximum concurrency without causing race conditions or unsafe operations, the <code>Machine</code> class uses <code>asyncio.Lock()</code> and <code>asyncio.Event()</code> for cooperative multitasking.</p> <p>These synchronization primitives are initialized in the constructor:</p> <pre><code>class Machine:\n    def __init__(self, connection, id: int, cam_index: int):\n        self.lock: asyncio.Lock = asyncio.Lock()\n        self.stop_event: asyncio.Event = asyncio.Event()\n        self.id: int = id\n        self.cam_index: int = cam_index\n        self.connection: SerialConnection = connection\n        self.devices: List[DeviceAction] = [\n            DeviceAction(connection, 18, 28, 1),\n            DeviceAction(connection, 105, 28, 2),\n            DeviceAction(connection, 192, 28, 3),\n            DeviceAction(connection, 279, 28, 4)\n        ]\n        self.is_running: bool = False\n        self.is_enabled: bool = True\n</code></pre>"},{"location":"architecture/#why-use-lock","title":"Why Use Lock?","text":"<p>Any function that mutates the state of the machine \u2014 like stopping a task \u2014 must acquire the lock first. This ensures that no two asynchronous routines modify or interfere with the machine at the same time.</p> <p>Here\u2019s an example from the <code>trigger_stop()</code> method:</p> <pre><code>async def trigger_stop(self):\n    async with self.lock:\n        self.stop_event.set()\n        self.is_running = False\n</code></pre>"},{"location":"architecture/#benefits-of-using-asynciolock","title":"Benefits of Using <code>asyncio.Lock()</code>","text":"<ol> <li> <p>Ensures safe command execution Prevents mid-task state changes, which could corrupt the machine\u2019s state or cause unexpected hardware behavior.</p> </li> <li> <p>Prevents overlapping access Since multiple tasks can be scheduled concurrently, the lock ensures one task finishes interacting with the machine before another begins.</p> </li> </ol>"},{"location":"settingup/","title":"Setting up the project","text":""},{"location":"settingup/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure the following tools are installed:</p> <ul> <li>Python 3.10+ \u2014 Main development language  </li> <li>Visual Studio Code (VSCode) \u2014 Recommended IDE  </li> <li>Virtual Environment \u2014 Optional but recommended for dependency isolation</li> </ul>"},{"location":"settingup/#installation-running-the-project","title":"\u2699\ufe0f Installation &amp; Running the Project","text":""},{"location":"settingup/#standard-setup","title":"Standard Setup","text":"<ol> <li> <p>Navigate to the root of the project:     <pre><code>cd path/to/project\n</code></pre></p> </li> <li> <p>Install dependencies using <code>pip</code>:     <pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Run the application:     <pre><code>python main.py\n</code></pre></p> </li> </ol>"},{"location":"settingup/#optional-using-uv-and-virtual-environment","title":"Optional: Using <code>uv</code> and Virtual Environment","text":"<p>This is a cleaner way to manage dependencies using <code>uv</code>, a fast Python package manager.</p> <ol> <li> <p>Navigate to the project folder:     <pre><code>cd path/to/project\n</code></pre></p> </li> <li> <p>Install <code>uv</code>:     <pre><code>pip install uv\n</code></pre></p> </li> <li> <p>Create a virtual environment:     <pre><code>uv venv\n</code></pre></p> </li> <li> <p>Activate the virtual environment:</p> <ul> <li> <p>Windows:   <pre><code>.venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>macOS/Linux:   <pre><code>source .venv/bin/activate\n</code></pre></p> </li> </ul> <p>\u26a0\ufe0f If the <code>uv</code> or <code>pip</code> command is not found, make sure the Python <code>Scripts/</code> folder is added to your system PATH environment variable.</p> </li> <li> <p>Install dependencies:     <pre><code>uv pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Run the app:     <pre><code>python main.py\n</code></pre></p> </li> <li> <p>You should see FastAPI running on <code>http://localhost:8000</code></p> </li> </ol>"}]}